import argparse
import datetime
import random
import requests
import string
import time

parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, description="Generate playlists from followed artists on Spotify.")
parser.add_argument("--token", required=True, default=argparse.SUPPRESS, help="token with \"user-follow-read\", \"playlist-modify-public\" and \"playlist-modify-private\" scopes from https://developer.spotify.com/console")
parser.add_argument("--include", nargs="+", choices=["single", "album", "compilation"], default=["single", "album"], help="releases to include")
parser.add_argument("--exclude", nargs="+", choices=["explicit", "remix"], default=[], help="tracks to exclude")
parser.add_argument("--delay", type=int, default=100, help="delay between requests in milliseconds")
parser.add_argument("--private", action="store_true", help="mark playlists as private")
args = parser.parse_args()
args.include = "%2C".join(args.include)

session = requests.Session()
session.headers.update({"Authorization": f"Bearer {args.token}"})

try:
	global user_id
	user_id = session.get("https://api.spotify.com/v1/me").json()["id"]
except Exception:
	raise Exception("INVALID TOKEN")


def grouped(items, n):
	return [items[i:i + n] for i in range(0, len(items), n)]


def uniqued(items, key):
	seen = set()
	return [item for item in items if key(item) not in seen and not seen.add(key(item))]


def parse_date(date):
	try:
		return datetime.datetime.strptime(date, "%Y-%m-%d")
	except Exception:
		try:
			return datetime.datetime.strptime(date, "%Y-%m")
		except Exception:
			try:
				return datetime.datetime.strptime(date, "%Y")
			except Exception:
				pass


def fetch_items(msg, url, id = "", key = "", i = 0):
	time.sleep(args.delay / 1000)
	res = session.get(url.replace("{id}", id)).json()
	if "error" in res:
		raise Exception("RATE LIMIT")
	data = res.get(key, res)
	i += len(data["items"])
	print(f"{msg:<72}{(i / data['total'] * 100):.0f}%", end=("\r" if data["next"] else "\n"))
	return data["items"] + fetch_items(msg, data["next"], id, key, i) if data["next"] else data["items"]


def push_tracks(tracks, n):
	playlist_id = session.post(f"https://api.spotify.com/v1/users/{user_id}/playlists", json={
		"name": f"SpotArt ({''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(4))}) - {n}",
		"description": "Generated by SpotArt from followed artists.",
		"public": not args.private
	}).json()["id"]
	for grouped_tracks in grouped(tracks, 100):
		session.post(f"https://api.spotify.com/v1/playlists/{playlist_id}/tracks", json={
			"uris": [track["uri"] for track in grouped_tracks]
		})


timestamp = time.time()
artist_count = 0
album_count = 0
tracks = []

for artist in fetch_items("Fetching artists... ", "https://api.spotify.com/v1/me/following?type=artist&limit=50", key="artists"):
	artist_count += 1
	for album in sorted(fetch_items(f"     {artist['name']}", f"https://api.spotify.com/v1/artists/{{id}}/albums?include_groups={args.include}&limit=50", artist["id"]), key=lambda album: parse_date(album["release_date"])):
		album_count += 1
		tracks += fetch_items(f"        {album['name']}", "https://api.spotify.com/v1/albums/{id}/tracks", album["id"])

tracks = [track for track in uniqued(tracks, key=lambda track: track["name"]) if not ("explicit" in args.exclude and track["explicit"]) and not ("remix" in args.exclude and "remix" in track["name"].lower())]
for i, _tracks in enumerate(grouped(tracks, 10000)):
	push_tracks(_tracks, i + 1)

print(f"Created {(len(tracks) / 10000 + 1):.0f} playlist(s) for {len(tracks)} unique tracks from {album_count} releases of {artist_count} artists in {((time.time() - timestamp) / 60):.0f} minute(s).")
